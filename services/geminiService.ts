
import { Trend, DeepAnalysisResult, GeneratedMetadata, NicheComparisonResult, MetadataConfig } from "../types";

const GROQ_MODEL = "meta-llama/llama-4-scout-17b-16e-instruct";
const GROQ_URL = "https://api.groq.com/openai/v1/chat/completions";

// Unified API key getter
const getApiKey = () => localStorage.getItem('user_api_key') || process.env.API_KEY || '';

type ErrorListener = (message: string) => void;
let globalErrorListener: ErrorListener | null = null;

export const setGlobalErrorListener = (listener: ErrorListener) => {
  globalErrorListener = listener;
};

const notifyError = (message: string) => {
  if (globalErrorListener) globalErrorListener(message);
};

// Robust JSON extraction from AI response
const cleanJsonString = (str: string) => {
    const start = str.indexOf('{');
    const end = str.lastIndexOf('}');
    if (start !== -1 && end !== -1) {
        return str.substring(start, end + 1);
    }
    // Fallback if it's an array
    const arrayStart = str.indexOf('[');
    const arrayEnd = str.lastIndexOf(']');
    if (arrayStart !== -1 && arrayEnd !== -1) {
        return str.substring(arrayStart, arrayEnd + 1);
    }
    return str.trim();
};

const callGroq = async (messages: any[], jsonMode: boolean = true) => {
  const apiKey = getApiKey();
  if (!apiKey) throw new Error("MISSING_API_KEY");

  const requestMessages = [...messages];
  if (jsonMode && !messages.some(m => m.role === 'system')) {
      requestMessages.unshift({ 
          role: "system", 
          content: "You are a specialized JSON assistant. Your output must ALWAYS be a single valid JSON object. Do not include any explanation or markdown formatting outside the object." 
      });
  }

  try {
    const response = await fetch(GROQ_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: GROQ_MODEL,
        messages: requestMessages,
        temperature: 0.1,
        max_completion_tokens: 3000,
        response_format: jsonMode ? { type: "json_object" } : undefined,
        stream: false
      })
    });

    if (response.status === 429) {
      throw new Error("RATE_LIMIT");
    }

    if (!response.ok) {
      const errData = await response.json().catch(() => ({}));
      throw new Error(errData.error?.message || `API Error: ${response.status}`);
    }

    const data = await response.json();
    let content = data.choices[0].message.content;
    
    if (jsonMode) {
        content = cleanJsonString(content);
    }
    
    return content;
  } catch (error: any) {
    if (error.message === "RATE_LIMIT") {
      notifyError("Your API key limit is reached. Please change or update your API key in Settings.");
    } else if (error.message === "MISSING_API_KEY") {
      notifyError("API Key is missing. Please add your Groq API key in Settings.");
    } else {
      notifyError(`Groq Error: ${error.message}`);
    }
    throw error;
  }
};

const generateRandomTrends = (count: number, type: 'general' | 'tshirt' | 'png' = 'general'): Trend[] => {
    const ADJECTIVES = ["Abstract", "Vintage", "Futuristic", "Minimalist", "Cyberpunk", "Authentic", "Sustainable", "Luxury"];
    const SUBJECTS = ["Coffee Culture", "Remote Work", "Electric Cars", "Smart Home", "Yoga Seniors", "Vertical Farming"];
    
    return Array.from({ length: count }).map((_, i) => {
        const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
        const subj = SUBJECTS[Math.floor(Math.random() * SUBJECTS.length)];
        const score = Math.floor(Math.random() * (99 - 75) + 75);
        return {
            id: `gen-${Date.now()}-${i}`,
            topic: `${adj} ${subj}`,
            niche: type === 'general' ? 'Commercial' : (type === 'tshirt' ? 'Print on Demand' : 'Isolated Asset'),
            competition: Math.random() > 0.5 ? 'Low' : 'Medium',
            category: 'Trending',
            description: `High demand ${type === 'general' ? 'stock photo' : 'design'} concept generated by AI.`,
            potentialEarnings: 'High',
            popularityScore: score,
            trendHistory: Array.from({length: 7}, () => Math.floor(Math.random() * 20 + 70))
        };
    });
};

export const fetchDailyTrends = async (): Promise<Trend[]> => {
  try {
    const prompt = 'Identify 9 diverse and profitable microstock niches. Return JSON: { "trends": [{id, topic, niche, competition, category, description, potentialEarnings, popularityScore, trendHistory[]}] }';
    const res = await callGroq([{ role: "user", content: prompt }]);
    return JSON.parse(res).trends || generateRandomTrends(6);
  } catch (error) {
    return generateRandomTrends(6);
  }
};

export const fetchMonthlyTrends = async (): Promise<Trend[]> => {
  try {
    const prompt = 'Identify 6 major upcoming holidays or seasonal events for the next 60 days. Return JSON: { "trends": [] }.';
    const res = await callGroq([{ role: "user", content: prompt }]);
    return JSON.parse(res).trends || generateRandomTrends(3);
  } catch (error) {
    return generateRandomTrends(3);
  }
};

export const fetchTShirtTrends = async (): Promise<Trend[]> => {
  try {
    const prompt = 'Identify 9 high-selling T-Shirt niches for Print on Demand. Return JSON: { "trends": [] }.';
    const res = await callGroq([{ role: "user", content: prompt }]);
    return JSON.parse(res).trends || generateRandomTrends(6, 'tshirt');
  } catch (error) {
    return generateRandomTrends(6, 'tshirt');
  }
};

export const fetchPngTrends = async (): Promise<Trend[]> => {
    try {
      const prompt = 'Identify 9 isolated PNG asset niches that are currently trending. Return JSON: { "trends": [] }.';
      const res = await callGroq([{ role: "user", content: prompt }]);
      return JSON.parse(res).trends || generateRandomTrends(6, 'png');
    } catch (error) {
      return generateRandomTrends(6, 'png');
    }
};

export const regenerateTrend = async (currentTrend: Trend): Promise<Trend | null> => {
    try {
        const prompt = `Generate one unique, high-profit microstock niche idea for the category: "${currentTrend.category}". Return JSON: { "trend": {id, topic, niche, competition, category, description, potentialEarnings, popularityScore, trendHistory[]} }.`;
        const res = await callGroq([{ role: "user", content: prompt }]);
        return JSON.parse(res).trend || null;
    } catch (error) {
        return null;
    }
};

export const deepAnalyzeTopic = async (topic: string): Promise<DeepAnalysisResult | null> => {
  try {
    const prompt = `Perform deep market analysis for: "${topic}". Return JSON: {nichePath, searchVolume, difficulty, visualStyle, composition, suggestedPrompt, relatedKeywords[], lowCompetitionAlternatives: [{topic, score, reason}]}.`;
    const res = await callGroq([{ role: "user", content: prompt }]);
    const data = JSON.parse(res);
    data.originalQuery = topic;
    return data;
  } catch (error) {
    return null;
  }
};

export const compareNiches = async (topicA: string, topicB: string): Promise<NicheComparisonResult> => {
  const prompt = `Compare these two microstock niches: "${topicA}" vs "${topicB}". Return JSON: {winner, winnerReason, topicA: {name, score, pros[], cons[]}, topicB: {name, score, pros[], cons[]}}.`;
  const res = await callGroq([{ role: "user", content: prompt }]);
  return JSON.parse(res);
};

export const generateMetadataFromFilename = async (filename: string, config: MetadataConfig): Promise<GeneratedMetadata | null> => {
  const prompt = `Generate commercial microstock Title, Description, and Keywords for file: "${filename}". Return JSON: {title, description, keywords[]}.`;
  const res = await callGroq([{ role: "user", content: prompt }]);
  return JSON.parse(res);
};

export const generateImageMetadata = async (base64Data: string, mimeType: string, config: MetadataConfig): Promise<GeneratedMetadata | null> => {
    const cleanBase64 = base64Data.includes('base64,') ? base64Data : `data:${mimeType};base64,${base64Data}`;
    
    const messages = [
        {
            role: "user",
            content: [
                { type: "text", text: `Analyze this image for commercial microstock. Output exactly JSON: {"title": "max 80 chars", "description": "detailed", "keywords": ["keyword1", "keyword2", ...]}. Keywords count: ${config.keywordCount}.` },
                { type: "image_url", image_url: { url: cleanBase64 } }
            ]
        }
    ];
    try {
        const res = await callGroq(messages);
        return JSON.parse(res);
    } catch (error) {
        console.error("Vision Error:", error);
        return null;
    }
};

export const generateSinglePrompt = async (topic: string, style: string, composition: string): Promise<string> => {
  const prompt = `Generate one professional AI image prompt for: "${topic}". Style: ${style}. Composition: ${composition}. Return JSON: { "prompt": "..." }.`;
  const res = await callGroq([{ role: "user", content: prompt }]);
  return JSON.parse(res).prompt || "";
};

export const generateBulkPrompts = async (topic: string, count: number, style: string, composition: string): Promise<string[]> => {
    const prompt = `Generate ${count} unique AI image prompts for: "${topic}". Style: ${style}. Return JSON: { "prompts": [] }.`;
    const res = await callGroq([{ role: "user", content: prompt }]);
    return JSON.parse(res).prompts || [];
};

export const fetchNichesByCategory = async (category: string): Promise<Trend[]> => {
    const prompt = `Identify 9 trending niches for microstock category: "${category}". Return JSON: { "trends": [] }.`;
    const res = await callGroq([{ role: "user", content: prompt }]);
    return JSON.parse(res).trends || [];
};

export const setDynamicApiKey = (key: string) => {
  localStorage.setItem('user_api_key', key);
};
